/*
 * graphics.c
 * 
 * Copyright 2013 JS-OS <js@duck-squirell>
 * 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
 * MA 02110-1301, USA.
 * 
 * 
 */

// Based on code from http://files.osdev.org/mirrors/geezer/osd/graphics/modes.c

#include <system.h>

u8int *vram = (unsigned char *)0xA0000;

extern u8int *vga_mem; //pointer to VESA Linear Frame Buffer
extern u8int *double_buffer; //double buffer for VESA video
extern u32int widthVESA, heightVESA, depthVESA; //size of VESA Screen attributes

//the vga identifiers
u32int VGA_width;
u32int VGA_height;
u32int VGA_bpp;

s32int isVESAon;
u8int *double_buffer; //double buffer for VESA video

void (*putPixel)(int, int, int);
void (*clearScreen)(void); //function pointer for clearing the screen
//~ void (*refreshScreen)(void); //function pointer for clearing the screen

#define	peekb(S,O)		*(unsigned char *)(16uL * (S) + (O))
#define	pokeb(S,O,V)		*(unsigned char *)(16uL * (S) + (O)) = (V)
#define	pokew(S,O,V)		*(unsigned short *)(16uL * (S) + (O)) = (V)
#define	_vmemwr(DS,DO,S,N)	memcpy((char *)((DS) * 16 + (DO)), S, N)

static unsigned get_fb_seg(void);


void putPixel_simpleStd(int x, int y, int color)
{

  int offset = x + VGA_width * y;

  /**Code for non-pallete color by changing DAC**/
  //~ outb(0x03c8, 15);
  //~ outb(0x03c9, (color>>16) & 0xff);
  //~ outb(0x03c9, (color>>8) & 0xff);
  //~ outb(0x03c9, color & 0xff);  
  /**Code for non-pallete color by changing DAC**/

  vram[offset] = color;
}

void putPixel_vga4Plane(int x, int y, int color)
{


  /**ADDED**/
  unsigned int tmpX = 0;
  
  int offset;

  unsigned int wd_in_bytes, off, mask, p, pmask;

  offset = x / 8 + (VGA_width / 8) * y;
  
  tmpX = (x & 7) * 1;
  mask = 0x80 >> tmpX;
  pmask = 1;
      
  for(p = 0; p < 4; p++)
  {
    set_plane(p);
    if(pmask & color)
    {
      //~ vpokeb(offset, vpeekb(offset) | mask);
      vram[offset] = vpeekb(offset) | mask;	  
    }else{
      //~ vpokeb(offset, vpeekb(offset) & ~mask);
      vram[offset] = vpeekb(offset) & ~mask;	  	  
    }
    pmask <<= 1;
  }

}

void putPixel_VESA(int x, int y, int RGB)
{

  /*calculates the offset for a specific point on screen*/
  int offset = x * (depthVESA / 8) + y * (widthVESA * (depthVESA / 8));

  vga_mem[offset + 0] = RGB & 0xff;           //BLUE
  vga_mem[offset + 1] = (RGB >> 8) & 0xff;    //GREEN
  vga_mem[offset + 2] = (RGB >> 16) & 0xff;   //RED

}

void putRect(int x, int y, int width, int height, int fill)
{
  int offset, tmpX = x, tmpY = y;
  
  for(y = tmpY; y < height + tmpY; y++)
    for(x = tmpX; x < width + tmpX; x++)
      putPixel(x, y, fill);
      
}

void putPixbufRect(int x, int y, int width, int height, int *pixbuf)
{
  int offset, tmpX = x, tmpY = y, color;
  int posX = 0, posY = 0;
  
  for(y = tmpY; y < height + tmpY; y++)
  {
    for(x = tmpX; x < width + tmpX; x++)
    {
      color = *(pixbuf + posX + width * posY);

      if(color != ALPHA)
        putPixel(x, y, color);

      posX++;
    }

    posX = 0;
    posY++;
  }
  
}

void putLine(int x1, int y1, int x2, int y2, int fill)
{
  u32int slopeNum = math_abs(y2 - y1);
  u32int slopeDenom = math_abs(x2 - x1);

  int tmpX, tmpY;

  if(x1 > x2)
  {
    tmpX = x1;
    tmpY = y1;
  }else{
    tmpX = x2;
    tmpY = y2;
  }

  int originalX = tmpX;
  float slope = slopeNum / slopeDenom;
  float runningUp;

  int x, y, offset;
  for(y = 0; y < slopeNum + 1; y++)
  {
    for(x = 0; x < slopeDenom + 1; x++)
    {
      offset = tmpX + 320 * tmpY;
  
      vram[offset] = fill;
      tmpX++;
      
    }
    tmpX = originalX;
    tmpY++;
  }
  
}

void putHVLine(int x, int y, int length, int color, char *HorV)
{
  int a, offset;

  if(*(HorV) == 'H') //draws a horizontal line
  {
    for(a = 0; a < length; a++)
    {
      offset = x + VGA_width * y;

      vram[offset] = color;

      x++;
    }
    
  }else if(*(HorV) == 'V') //draws a verticle line
  {
    for(a = 0; a < length; a++)
    {
      offset = x + VGA_width * y;

      vram[offset] = color;

      y++;
    }

  }
  
}

void putBorderOnObject(objects *object, int index)
{

  putRect(object[index].x, object[index].y, object[index].width, object[index].borderSize, object[index].borderColor);
  putRect(object[index].x, object[index].y + object[index].height - object[index].borderSize, object[index].width, object[index].borderSize, object[index].borderColor);
  
  putRect(object[index].x, object[index].y, object[index].borderSize, object[index].height, object[index].borderColor);
  putRect(object[index].x + object[index].width - object[index].borderSize, object[index].y, object[index].borderSize, object[index].height, object[index].borderColor);
}

int font1[26][8] = //26 sets to represent the 26 letters, 8 binary numbers
{
  { 0b00011000, //A
    0b00100100,
    0b01000010,
    0b01111110,
    0b01000010,
    0b01000010,
    0b00000000,
    0b00000000
  },
  { 0b01111100, //B
    0b01000010,
    0b01111100,
    0b01000010,
    0b01000010,
    0b01111100,
    0b00000000,
    0b00000000
  },
  { 0b00111100, //C
    0b01000010,
    0b01000000,
    0b01000000,
    0b01000010,
    0b00111100,
    0b00000000,
    0b00000000
  },
  { 0b01111100, //D
    0b01000010,
    0b01000010,
    0b01000010,
    0b01000010,
    0b01111100,
    0b00000000,
    0b00000000
  },
  { 0b01111110, //E
    0b01000000,
    0b01111100,
    0b01000000,
    0b01000000,
    0b01111110,
    0b00000000,
    0b00000000
  },
  { 0b01111110, //F
    0b01000000,
    0b01111100,
    0b01000000,
    0b01000000,
    0b01000000,
    0b00000000,
    0b00000000
  },
  { 0b00111100, //G
    0b01000010,
    0b01000000,
    0b01001110,
    0b01000010,
    0b00111110,
    0b00000000,
    0b00000000
  },
  { 0b01000010, //H
    0b01000010,
    0b01000010,
    0b01111110,
    0b01000010,
    0b01000010,
    0b00000000,
    0b00000000
  },
  { 0b00010000, //I
    0b00010000,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00000000,
    0b00000000
  },
  { 0b00000010, //J
    0b00000010,
    0b00000010,
    0b00000010,
    0b01000010,
    0b00111100,
    0b00000000,
    0b00000000
  },
  { 0b01000010, //K
    0b01000100,
    0b01001000,
    0b01111000,
    0b01000100,
    0b01000010,
    0b00000000,
    0b00000000
  },
  { 0b01000000, //L
    0b01000000,
    0b01000000,
    0b01000000,
    0b01000000,
    0b01111110,
    0b00000000,
    0b00000000
  },
  { 0b01000010, //M
    0b01100110,
    0b01011010,
    0b01000010,
    0b01000010,
    0b01000010,
    0b00000000,
    0b00000000
  },
  { 0b01000010, //N
    0b01100010,
    0b01010010,
    0b01001010,
    0b01000110,
    0b01000010,
    0b00000000,
    0b00000000
  },
  { 0b00111100, //O
    0b01000010,
    0b01000010,
    0b01000010,
    0b01000010,
    0b00111100,
    0b00000000,
    0b00000000
  },
  { 0b01111100, //P
    0b01000010,
    0b01000010,
    0b01111100,
    0b01000000,
    0b01000000,
    0b00000000,
    0b00000000
  },
  { 0b00111100, //Q
    0b01000010,
    0b01000010,
    0b01000010,
    0b01001010,
    0b00111100,
    0b00000010,
    0b00000000
  },
  { 0b01111100, //R
    0b01000010,
    0b01000010,
    0b01111100,
    0b01000100,
    0b01000010,
    0b00000000,
    0b00000000
  },
  { 0b00111100, //S
    0b01000010,
    0b00110000,
    0b00001100,
    0b01000010,
    0b00111100,
    0b00000000,
    0b00000000
  },
  { 0b01111110, //T
    0b00010000,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00000000,
    0b00000000
  },
  { 0b01000010, //U
    0b01000010,
    0b01000010,
    0b01000010,
    0b01000010,
    0b00111100,
    0b00000000,
    0b00000000
  },
  { 0b01000010, //V
    0b01000010,
    0b00100100,
    0b00100100,
    0b00011000,
    0b00011000,
    0b00000000,
    0b00000000
  },
  { 0b10000001, //W
    0b10000001,
    0b10011001,
    0b10011001,
    0b01100110,
    0b01000010,
    0b00000000,
    0b00000000
  },
  { 0b01000010, //X
    0b00100100,
    0b00011000,
    0b00011000,
    0b00100100,
    0b01000010,
    0b00000000,
    0b00000000
  },
  { 0b01000010, //Y
    0b01000010,
    0b00111100,
    0b00010000,
    0b00010000,
    0b00010000,
    0b00000000,
    0b00000000
  },
  { 0b01111110, //Z
    0b00000100,
    0b00001000,
    0b00010000,
    0b00100000,
    0b01111110,
    0b00000000,
    0b00000000
  }

};

void putGraphicChar(char *letter, int x, int y, int color, int fontSize)
{
  int offset, index, encodedLine, modNumber;

  int asciiCharToPrint = *(letter) - 65; //gest the index of the char to print

  int tmpX = x, tmpY = y;

  for(y = tmpY; y < tmpY + fontSize; y++)
  {
    encodedLine = font1[asciiCharToPrint][y - tmpY];

    if(encodedLine != 0) //if there is atleast one pixel on that line
    {
      
      for(x = tmpX; x < tmpX + fontSize; x++)
      {
        offset = x + VGA_width * y; //place to draw

        index = fontSize - (x - tmpX) - 1; //finds the index of the number, if x == tmpX, ie: wants to draw 0 pixel if the array is 0b01111111, then it goes to 1 in -> direction

        modNumber = math_pow(2, index); //finds the max number that the encoded line for the next step is an optimization

        if(encodedLine - modNumber >= 0) //if the max number is greater than the encoded line, then there must be no pixel on the index so skip drawing
        {
          putPixel(x, y, color);
          encodedLine = encodedLine - modNumber;
        }
        
      }
    }
      
  }
  
}

void putGraphicString(char *string, int x, int y, int color, int fontSize)
{
  int length = k_strlen(string), moveX = (int)(fontSize * (9 / 8));

  int a;
  for(a = 0; a < length; a++)
  {
    putGraphicChar(string, x, y, color, fontSize);

    x = x + moveX;
    string++;
  }
}

int getPixelColor(int x, int y)
{
  int offset = x + VGA_width * y;

  return vram[offset];
}

int isObjectAbovePoint(int x, int y, objects *object, int index)
{
  if(object[index].x > x || object[index].y > y)
    return FALSE; //object is not over point (x,y)
  else if(object[index].x <= x && object[index].y <= y && 
          (object[index].x + object[index].width) > x && 
          (object[index].y + object[index].height) > y)
    return TRUE; //object is over point (x,y)
  else
    return FALSE; //object is not over point (x,y)

}

int indexOfHighestObjectAbovePoint(int x, int y, objects *object, int numberOfObjects)
{

  int a, highestPriority = 0, currentPriority, highestObject = 0;
  
  for(a = 0; a < numberOfObjects; a++)
  {
    currentPriority = object[a].priority;

    if(currentPriority >= highestPriority && isObjectAbovePoint(x, y, &object[0], a) == TRUE) //if this object "a" has a higher priority than the one before it and is above the input point
    {
      highestObject = a;
    }
  }

  return highestObject;
}

int isAttributeAbovePoint(int pointX, int pointY, int x, int y, int width, int height)
{
  if(x > pointX || y > pointY)
    return FALSE; //object is not over point (x,y)
  else if(x <= pointX && y <= pointY && (x + width) >= pointX && (y + height) >= pointY)
    return TRUE; //object is over point (x,y)
  else
    return FALSE; //object is not over point (x,y)

}

int objectsCollision(objects *object, int firstIndex, int secondIndex, int xBufferCollision, int yBufferCollision)
{

  int a = object[firstIndex].x - xBufferCollision, b = object[firstIndex].y - yBufferCollision;

  if(a < 0) //for x in for loop
    a = 0;
  else if(a > VGA_width)
    a = VGA_width;

  if(b < 0) //for y in for loop
    b = 0;
  else if(b > VGA_height)
    b = VGA_height;
  
  int x, y, collision = 0;

  int width = object[firstIndex].x + object[firstIndex].width + xBufferCollision;
  int height = object[firstIndex].y + object[firstIndex].height + yBufferCollision;
  int changedX = a;
  int changedY = b;
  
  for(x = a; x < object[firstIndex].x + object[firstIndex].width + xBufferCollision; x++)
  {
    for(y = b; y < object[firstIndex].y + object[firstIndex].height + yBufferCollision; y++)
    {
      if(isAttributeAbovePoint(x, y, changedX, changedY, width, height) == TRUE && 
         isObjectAbovePoint(x, y, &object[0], secondIndex) == TRUE)
      {
        return TRUE;
        collision = 1;
        break;
      }
    }
  }

  if(!collision)
    return FALSE;
  
}

//TODO add getPixbufWidth functionality
int getPixbufWidth(int *pixbuf)
{

}

//TODO add getPixbufHeight functionality
int getPixbufHeight(int *pixbuf)
{

}

int indexOfObjectBelow(objects *number, int numberOfObjects, int indexOfObjectToLookUnder, int x, int y)
{
  int a, indexPriority = number[indexOfObjectToLookUnder].priority;
  int lastPriority = 0, objectUnder = 0;
  
  for(a = 0; a < numberOfObjects; a++)
  {
    if(number[a].priority > lastPriority && number[a].priority < indexPriority && //if this testing priority > than the previous one and is < the one inputed
       a != indexOfObjectToLookUnder && isObjectAbovePoint(x, y, &number[0], a) == TRUE && //if the testing priority != to the inputed on and if the object being tested if under is under the inputed object
       number[a].shouldHide == FALSE) //the object below should not be hidden
    {
      lastPriority = number[a].priority;
      objectUnder = a;
    }
  }

  return objectUnder;
}

int numberOfHiddenObjects(objects *object, int numberOfObjects)
{

  u32int a, hidden = 0;

  for(a = 0; a < numberOfObjects; a++)
    if(object[a].shouldHide == TRUE)
      hidden++; 

  return hidden;
}

void refreshObjects(objects *number, int numberOfObjects, int indexToRefresh, int xBuffer, int yBuffer, int *pixbuf)
{ 
  int width = number[indexToRefresh].width;
  int height = number[indexToRefresh].height;
  
  int x, y;
  int xPos = number[indexToRefresh].x, yPos = number[indexToRefresh].y, n, color;

  float highestPriority = 0, currentPriority = 0;

  int a = xPos - xBuffer, b = yPos - yBuffer;

  if(a < 0) //for x in for loop
    a = 0;
  else if(a > VGA_width)
    a = VGA_width;

  if(b < 0) //for y in for loop
    b = 0;
  else if(b > VGA_height)
    b = VGA_height;

  int xLoopNumber = xPos + width + xBuffer;

  if(xLoopNumber > VGA_width) //should not refresh anything if it exceeds the VGA_width
    xLoopNumber = VGA_width;

  int shouldPutPixel = TRUE, objectRightBelow = 0;

  for(y = b; y < yPos + height + yBuffer; y++)
  {  
    for(x = a; x < xLoopNumber; x++)
    {

      for(n = 0; n < numberOfObjects; n++)
      {
        if(isObjectAbovePoint(x, y, &number[0], n) == TRUE && number[n].shouldHide == FALSE) //if the object at point (x,y) is over that point and is not set to hidden (hidden meaning invisible, minimized)
        {
          currentPriority = number[n].priority;
          
          if(currentPriority >= highestPriority) //if this object has a higher priority than the one before it
          {
            highestPriority = currentPriority;
            
            if(number[n].color == -1) //-1 signalizes that the color is a pixbuf
            {
              color = *(pixbuf + (x - xPos) + width * (y - yPos));
              if(color == ALPHA) //if the color in the pixbuf is listed as an ALPHA
              {
                //~ shouldPutPixel = FALSE;
                objectRightBelow = indexOfObjectBelow(&number[0], numberOfObjects, n, x, y);

                if(number[objectRightBelow].borderSize != 0) //checks if objects has a border
                {
                  if(number[objectRightBelow].x <= x && number[objectRightBelow].x +
                     number[objectRightBelow].borderSize > x) //checks if refreshing point is on left border
                  {
                    color = number[objectRightBelow].borderColor;

                  }else if(number[objectRightBelow].x + number[objectRightBelow].width -
                           number[objectRightBelow].borderSize - 1 < x) //checks if refreshing point is on left border
                  {
                    color = number[objectRightBelow].borderColor;


                  }else if(number[objectRightBelow].y <= y && number[objectRightBelow].y +
                           number[objectRightBelow].borderSize > y) //checks if refreshing point is on top border
                  {
                    color = number[objectRightBelow].borderColor;
                    
                  }else if(number[objectRightBelow].y + number[objectRightBelow].height - number[objectRightBelow].borderSize - 1 < y) //&& number[objectRightBelow].y +
                  {
                    color = number[objectRightBelow].borderColor;
                    
                  }else{
                    color = number[objectRightBelow].color;
                  }
                  
                }else{
                  color = number[objectRightBelow].color;
                }
              }
            }else{

              if(number[n].borderSize)//checks if objects has a border
              {
                if(number[n].x <= x && number[n].x + number[n].borderSize > x) //checks if refreshing point is on left border
                {
                  color = number[n].borderColor;

                }else if(number[n].x + number[n].width - number[n].borderSize - 1 < x)
                {
                  color = number[n].borderColor;

                }else if(number[n].y <= y && number[n].y + number[n].borderSize > y)
                {
                  color = number[n].borderColor;
                  
                }else if(number[n].y + number[n].height - number[n].borderSize - 1 < y)
                {
                  color = number[n].borderColor;

                }else{
                  color = number[n].color;
                }
              }else{
                color = number[n].color;
              }              
              
            }
            
          }
        }

      }

      putPixel(x, y, color);
      highestPriority = 0; //resets the highest priority since we are moving to a new pixel
      
    }
  }
  
}

void refreshScreen_std(objects *number, int numberOfObjects)
{
  int x, y, n, color;
  float highestColor = 0, currentPriority = 0;
  
  for(x = 0; x < VGA_width; x++)
  {
    for(y = 0; y < VGA_height; y++)
    {
      for(n = 0; n < numberOfObjects; n++)
      {
        if(isObjectAbovePoint(x, y, &number[0], n) == 1)
        {
          currentPriority = number[n].priority;
          
          if(currentPriority >= highestColor)
          {
            highestColor = currentPriority;
            color = number[n].color;
            
          }
        }

      }
      
      putPixel(x, y, color);
      highestColor = 0;      
    }
  }
  
}

void refreshScreen_VESA()
{
  vsync();

  //set the double buffer to the physical graphics memmory (vga_mem)
  g_flip(double_buffer, (widthVESA * heightVESA * (depthVESA / 8)));
  
}

void refreshArea_VESA(int x, int y, int width, int height)
{
  vsync();

  int a, offset;

  offset = x * (depthVESA / 8) + y * widthVESA * (depthVESA / 8);

  for(a = 0; a < height; a++)
  {
    offset = offset + widthVESA * (depthVESA / 8);
    memcpy(vga_mem + offset, double_buffer + offset, width * (depthVESA / 8));
  }
  
}

void writePixelToDoubleBuffer(unsigned x, unsigned y, unsigned RGB)
{
  /*calculates the offset for a specific point on screen*/
  int offset = x * (depthVESA / 8) + y * (widthVESA * (depthVESA / 8));


  if(RGB != ALPHA)
  {
    double_buffer[offset + 0] = RGB & 0xff;           //BLUE
    double_buffer[offset + 1] = (RGB >> 8) & 0xff;    //GREEN
    double_buffer[offset + 2] = (RGB >> 16) & 0xff;   //RED
  }

}

void write_buffer(unsigned x, unsigned y, unsigned width, unsigned height, u32int *buffer)
{
  u32int j, h;
  
  for(j = y; j < y + height; j++)
    for(h = x; h < x + width; h++)
      writePixelToDoubleBuffer(h, j, buffer[((j - y) * width) + (h - x)]);
}

void plot_BufPixel(int x, int y, int RGB, int width, u32int *buffer)
{

  /*calculates the offset for a specific point on screen*/  
  u32int offset = x + y * width;

  if(RGB != PLOT_ALPHA) //if the pixel is not an alpha pixel
    buffer[offset] = RGB;           //COLOR

}

void plot_BufRect(int x, int y, int width, int height, int isPixbuf, long *pixbuf, int fill, int widthOfWholeWindow, u32int *buffer)
{

  int tmpX = x, tmpY = y;


  //TODO add plot_BufRect with a pixbuf
  if(isPixbuf == TRUE)
  {
    int a, b, offset, color;
    
    for(a = tmpX; a < tmpX + width; a++)
    {
      for(b = tmpY; b < tmpY + height; b++)
      {
	offset = (a - tmpX) + (b - tmpY) * width;
	color = pixbuf[offset];
        plot_BufPixel(a, b, color, widthOfWholeWindow, buffer);
      }
    }
  }else if(isPixbuf == FALSE)
  {
    int a, b;
    
    for(a = tmpX; a < tmpX + width; a++)
      for(b = tmpY; b < tmpY + height; b++)
	plot_BufPixel(a - tmpX + x, b - tmpY + y, fill, widthOfWholeWindow, buffer);
  }


}

void plot_BufChar(char *letter, int x, int y, int color, int fontSize, int widthOfWindow, u32int *buffer)
{
  int offset, index, encodedLine, modNumber;

  int asciiCharToPrint = *(letter) - 65; //gest the index of the char to print

  int tmpX = x, tmpY = y;

  for(y = tmpY; y < tmpY + fontSize; y++)
  {
    encodedLine = font1[asciiCharToPrint][y - tmpY];

    if(encodedLine != 0) //if there is atleast one pixel on that line
    {
      
      for(x = tmpX; x < tmpX + fontSize; x++)
      {

        index = fontSize - (x - tmpX) - 1; //finds the index of the number, if x == tmpX, ie: wants to draw 0 pixel if the array is 0b01111111, then it goes to 1 in -> direction

        modNumber = math_pow(2, index); //finds the max number that the encoded line for the next step is an optimization

        if(encodedLine - modNumber >= 0) //if the max number is greater than the encoded line, then there must be no pixel on the index so skip drawing
        {
          plot_BufPixel(x, y, color, widthOfWindow, buffer);
          encodedLine = encodedLine - modNumber;
        }
        
      }
    }
      
  }
  
}

void plot_BufString(int x, int y, char *string, int color, int widthOfWholeWindow, u32int *buffer)
{

  u32int length = k_strlen(string);

  u32int a;
  
  for(a = 0; a < length; a++)
  {
    plot_BufChar(string, x, y, color, 8, widthOfWholeWindow, buffer);

    string++;
    x += 8;
  }

}

void refreshArea(objects *number, int numberOfObjects, int topLeftX, int topLeftY, int width, int height)
{

  int a, b, n, color;

  float highestColor = 0, currentPriority = 0;

  int xLoopNumber = topLeftX + width;

  if(xLoopNumber > VGA_width)
  {
    xLoopNumber = VGA_width;
  }
  
  for(a = topLeftX; a < xLoopNumber; a++)
  {
    for(b = topLeftY; b < topLeftY + height; b++)
    {
      for(n = 0; n < numberOfObjects; n++)
      {
        if(isObjectAbovePoint(a, b, &number[0], n) == 1)
        {
          currentPriority = number[n].priority;
          
          if(currentPriority >= highestColor)
          {
            highestColor = currentPriority;
            color = number[n].color;
            
          }
        }

      }
      
      putPixel(a, b, color);
      highestColor = 0;      
    }
  }

  
}

//define the ports , taken from http://files.osdev.org/mirrors/geezer/osd/graphics/modes.c
#define   VGA_AC_INDEX             0x3C0
#define   VGA_AC_WRITE             0x3C0
#define   VGA_AC_READ              0x3C1
#define   VGA_MISC_WRITE           0x3C2
#define   VGA_SEQ_INDEX            0x3C4
#define   VGA_SEQ_DATA             0x3C5
#define   VGA_DAC_READ_INDEX       0x3C7
#define   VGA_DAC_WRITE_INDEX      0x3C8
#define   VGA_DAC_DATA             0x3C9
#define   VGA_MISC_READ            0x3CC
#define   VGA_GC_INDEX             0x3CE
#define   VGA_GC_DATA              0x3CF
#define   VGA_CRTC_INDEX           0x3D4      /* 0x3B4 */
#define   VGA_CRTC_DATA            0x3D5      /* 0x3B5 */
#define   VGA_INSTAT_READ          0x3DA
#define   VGA_NUM_SEQ_REGS         5
#define   VGA_NUM_CRTC_REGS        25
#define   VGA_NUM_GC_REGS          9
#define   VGA_NUM_AC_REGS          21
#define   VGA_NUM_REGS      (1+VGA_NUM_SEQ_REGS+VGA_NUM_CRTC_REGS+VGA_NUM_GC_REGS+VGA_NUM_AC_REGS)

unsigned char g_640x480x16[] =
{
/* MISC */
  0xE3,
/* SEQ */
  0x03, 0x01, 0x08, 0x00, 0x06,
/* CRTC */
  0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0x0B, 0x3E,
  0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0xEA, 0x0C, 0xDF, 0x28, 0x00, 0xE7, 0x04, 0xE3,
  0xFF,
/* GC */
  0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x05, 0x0F,
  0xFF,
/* AC */
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
  0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
  0x01, 0x00, 0x0F, 0x00, 0x00
};

unsigned char g_720x480x16[] =
{
/* MISC */
  0xE7,
/* SEQ */
  0x03, 0x01, 0x08, 0x00, 0x06,
/* CRTC */
  0x6B, 0x59, 0x5A, 0x82, 0x60, 0x8D, 0x0B, 0x3E,
  0x00, 0x40, 0x06, 0x07, 0x00, 0x00, 0x00, 0x00,
  0xEA, 0x0C, 0xDF, 0x2D, 0x08, 0xE8, 0x05, 0xE3,
  0xFF,
/* GC */
  0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x05, 0x0F,
  0xFF,
/* AC */
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
  0x01, 0x00, 0x0F, 0x00, 0x00,
};

/**
 * CREATE THE REGISTER ARRAY TAKEN FROM http://wiki.osdev.org/VGA_Hardware
 */
unsigned char mode_320_200_256[]={
  /* MISC
   *
   * 0x63 => 01100011
   * 7 6 5 4 3 2 1 0
   * 1 1 0 0 0 1 1 0
   * VSP HSP - - CS CS ERAM IOS
   * 7,6 - 480 lines
   * 5,4 - free
   * 3,2 - 28,322 MHZ Clock
   * 1 - Enable Ram
   * 0 - Map 0x3d4 to 0x3b4
   */
  0x63,
  /* SEQ */
  /**
   * index 0x00 - Reset
   * 0x03 = 11
   * Bits 1,0 Synchronous reset
   */
  0x03,
  /**
   * index 0x01
   * Clocking mode register
   * 8/9 Dot Clocks
   */
  0x01,
  /**
   * Map Mask Register, 0x02
   * 0x0F = 1111
   * Enable all 4 Maps Bits 0-3
   * chain 4 mode
   */
  0x0F,
  /**
   * map select register, 0x03
   * no character map enabled
   */
  0x00,
  /**
   * memory mode register 0x04
   * enables ch4,odd/even,extended memory
   */
  0x0E,
  /* CRTC */
  0x5F, 0x4F, 0x50, 0x82, 0x54, 0x80, 0xBF, 0x1F,
  0x00, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x9C, 0x0E, 0x8F, 0x28,   0x40, 0x96, 0xB9, 0xA3,
  0xFF,
  /* GC */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x05, 0x0F,
  0xFF,
  /* AC */
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
  0x41, 0x00, 0x0F, 0x00,   0x00
};

unsigned char g_80x25_text[] =
{
/* MISC */
  0x67,
/* SEQ */
  0x03, 0x00, 0x03, 0x00, 0x02,
/* CRTC */
  0x5F, 0x4F, 0x50, 0x82, 0x55, 0x81, 0xBF, 0x1F,
  0x00, 0x4F, 0x0D, 0x0E, 0x00, 0x00, 0x00, 0x50,
  0x9C, 0x0E, 0x8F, 0x28, 0x1F, 0x96, 0xB9, 0xA3,
  0xFF,
/* GC */
  0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x0E, 0x00,
  0xFF,
/* AC */
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x14, 0x07,
  0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
  0x0C, 0x00, 0x0F, 0x08, 0x00
};

void write_registers(unsigned char *regs)
{
  unsigned i;


  /* write MISCELLANEOUS reg */
  outb(VGA_MISC_WRITE, *regs);
  regs++;
  /* write SEQUENCER regs */
  for(i = 0; i < VGA_NUM_SEQ_REGS; i++)
  {
    outb(VGA_SEQ_INDEX, i);
    outb(VGA_SEQ_DATA, *regs);
    regs++;
  }
  /* unlock CRTC registers */
  outb(VGA_CRTC_INDEX, 0x03);
  outb(VGA_CRTC_DATA, inb(VGA_CRTC_DATA) | 0x80);
  outb(VGA_CRTC_INDEX, 0x11);
  outb(VGA_CRTC_DATA, inb(VGA_CRTC_DATA) & ~0x80);
  /* make sure they remain unlocked */
  regs[0x03] |= 0x80;
  regs[0x11] &= ~0x80;
  /* write CRTC regs */
  for(i = 0; i < VGA_NUM_CRTC_REGS; i++)
  {
    outb(VGA_CRTC_INDEX, i);
    outb(VGA_CRTC_DATA, *regs);
    regs++;
  }
  /* write GRAPHICS CONTROLLER regs */
  for(i = 0; i < VGA_NUM_GC_REGS; i++)
  {
    outb(VGA_GC_INDEX, i);
    outb(VGA_GC_DATA, *regs);
    regs++;
  }
  /* write ATTRIBUTE CONTROLLER regs */
  for(i = 0; i < VGA_NUM_AC_REGS; i++)
  {
    (void)inb(VGA_INSTAT_READ);
    outb(VGA_AC_INDEX, i);
    outb(VGA_AC_WRITE, *regs);
    regs++;
  }

   
  /* lock 16-color palette and unblank display */
  (void)inb(VGA_INSTAT_READ);
  outb(VGA_AC_INDEX, 0x20);
   
}

static void vsync()
{
  /*wait until any previous retrace has ended*/
  do {
  } while (inb(0x3DA) & 8);
  
  /*wait until a new retrace has just begun*/
  do {
  } while (!(inb(0x3DA) & 8));
}

static void g_flip(unsigned char *source, u32int count)
{
  memcpy(vga_mem, source, count);
}

static void set_plane(unsigned p)
{
  unsigned char pmask;

  p &= 3;
  pmask = 1 << p;
/* set read plane */
  outb(VGA_GC_INDEX, 4);
  outb(VGA_GC_DATA, p);
/* set write plane */
  outb(VGA_SEQ_INDEX, 2);
  outb(VGA_SEQ_DATA, pmask);

  //~ outb(VGA_SEQ_INDEX, p);
  
}

static void vpokeb(unsigned int off, unsigned int val)
{
  pokeb(get_fb_seg(), off, val);
}

static unsigned vpeekb(unsigned off)
{
  return peekb(get_fb_seg(), off);
}

/**ADDED**/
/* bitmap "class" */
typedef struct
{
  unsigned int wd, ht;
  unsigned char *raster;
  unsigned int fore_color, back_color;
/* "member functions" */
  const struct _driver *ops;
}bmp_t;

void vmemset(unsigned char *s, unsigned c, unsigned n)
{
  for(; n != 0; n--)
  {
    *s = c;
    s++;
  }
}

void fill_plane(char *bmp, int x, int y, int wd, int ht, unsigned c)
{
  unsigned int w, wd_in_bytes, off;
  unsigned char lmask, rmask;
  int x2, y2;

  x2 = x + wd - 1;
  w = (x2 >> 3) - (x >> 3) + 1;
  lmask = 0x00FF >> (x & 7); /* FF 7F 3F 1F 0F 07 03 01 */
  rmask = 0xFF80 >> (x2 & 7);/* 80 C0 E0 F0 F8 FC FE FF */
  if(w == 1)
  {
    lmask &= rmask;
  }
  wd_in_bytes = VGA_width;
  off = wd_in_bytes * y + x / 8;
  if(c)
/* for each row... */
    for(y2 = y; y2 < y + ht; y2++)
    {
/* do partial byte on left */
      bmp[off] |= lmask;
/* do solid bytes in middle */
      if(w > 2)
        vmemset(bmp + off + 1, 0xFF, w - 2);
/* do partial byte on right */
      if(w > 1)
        bmp[off + w - 1] |= rmask;
/* next row */
      off += wd_in_bytes;
    }else{
    lmask = ~lmask;
    rmask = ~rmask;
    for(y2 = y; y2 < y + ht; y2++)
    {
      bmp[off] &= lmask;
      if(w > 2)
	vmemset(bmp + off + 1, 0, w - 2);
      if(w > 1)
	bmp[off + w - 1] &= rmask;
      off += wd_in_bytes;
    }
  }
}

/**
 * Clears the VGA screen
 */
void VGA_clear_screen()
{
  unsigned int x = 0;
  unsigned int y = 0;
    
  for(y = 0; y < VGA_height; y++)
  {
    for(x = 0; x < VGA_width; x++)
    {
      if(isVESAon == ON) //if VESA is on, use 0xffffff as white since there is no pallete
      {
	putPixel(x, y, 0xffffff);
	//~ memset(vga_mem, 0xff, (widthVESA * heightVESA));
      }else if(isVESAon == OFF) //if VESA is off, use 15 as white since there is a standard pallete
      {
	putPixel(x, y, 15);
      }
    }
  }

}

void VGA_init(int width, int height, int bpp)
{
  k_save();
  //setup the vga struct

  //set the colors for the VGA graphics modes
  outb(0x3c8, 0x0f);
  outb(0x3c9, 0x3f);
  outb(0x3c9, 0x3f);
  outb(0x3c9, 0x3f);
   
  VGA_width = (unsigned int)width;
  VGA_height = (unsigned int)height;
  VGA_bpp = bpp;
  //~ VGA_address = (unsigned char *)0xA0000;

  //enables the mode 13 state
  if(width == 320 && height == 200 && bpp == 256)
  {
    isVESAon = OFF;    
    write_registers(mode_320_200_256);
    putPixel = putPixel_simpleStd;
    //~ refreshScreen = refreshScreen_std;

    //clears the screen
    VGA_clear_screen();    
  }else if(width == 720 && height == 480 && bpp == 16)
  {
    isVESAon = OFF;
    write_registers(g_720x480x16);
    putPixel = putPixel_vga4Plane;

    //clears the screen
    VGA_clear_screen();    
  }else if(width == 640 && height == 480 && bpp == 16)
  {
    isVESAon = OFF;
    write_registers(g_640x480x16);
    putPixel = putPixel_vga4Plane;
    
    //clears the screen
    VGA_clear_screen();    
  }else if(width == 1024 && height == 768 && bpp == 24)
  {
    double_buffer = (u8int*)kmalloc((width * height) * (bpp / 8));

    //~ k_printf("\ndouble buffer: %h\n", double_buffer);
    
    memset(double_buffer, 0xff, width * height * (bpp / 8));

    //~ k_printf("double buffer content: %h %h %h %h %h %h %h\n", double_buffer[0], double_buffer[1], double_buffer[2], double_buffer[3], double_buffer[4], double_buffer[5]);
    //~ k_printf("Double buffer addresses: %h %h %h %h %h %h %h %h\n", &double_buffer[0], &double_buffer[1], &double_buffer[2], &double_buffer[3], &double_buffer[4], &double_buffer[5], &double_buffer[6]);

    //~ while(1);

    isVESAon = ON;
    setVesa(0x118); //1024x768x24
    putPixel = putPixel_VESA;
  
  }
  
}

static unsigned get_fb_seg(void)
{
  unsigned seg;
  
  outb(VGA_GC_INDEX, 6);
  seg = inb(VGA_GC_DATA);
  seg >>= 2;
  seg &= 3;
  switch(seg)
  {
  case 0:
  case 1:
    seg = 0xA000;
    break;
  case 2:
    seg = 0xB000;
    break;
  case 3:
    seg = 0xB800;
    break;
  }
  return seg;
}

static void vmemwr(unsigned dst_off, unsigned char *src, unsigned count)
{
  _vmemwr(get_fb_seg(), dst_off, src, count);
}


static unsigned char g_8x16_font[4096] =
{
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0x81, 0xBD, 0x99, 0x81, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x7E, 0xFF, 0xDB, 0xFF, 0xFF, 0xC3, 0xE7, 0xFF, 0xFF, 0x7E, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x6C, 0xFE, 0xFE, 0xFE, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x7C, 0xFE, 0x7C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0xE7, 0xE7, 0xE7, 0x99, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x18, 0x3C, 0x7E, 0xFF, 0xFF, 0x7E, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x42, 0x42, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xC3, 0x99, 0xBD, 0xBD, 0x99, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x00, 0x00, 0x1E, 0x0E, 0x1A, 0x32, 0x78, 0xCC, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x3F, 0x33, 0x3F, 0x30, 0x30, 0x30, 0x30, 0x70, 0xF0, 0xE0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x7F, 0x63, 0x7F, 0x63, 0x63, 0x63, 0x63, 0x67, 0xE7, 0xE6, 0xC0, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x18, 0x18, 0xDB, 0x3C, 0xE7, 0x3C, 0xDB, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFE, 0xF8, 0xF0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x02, 0x06, 0x0E, 0x1E, 0x3E, 0xFE, 0x3E, 0x1E, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x7F, 0xDB, 0xDB, 0xDB, 0x7B, 0x1B, 0x1B, 0x1B, 0x1B, 0x1B, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x7C, 0xC6, 0x60, 0x38, 0x6C, 0xC6, 0xC6, 0x6C, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x18, 0x3C, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x0C, 0xFE, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x60, 0xFE, 0x60, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xC0, 0xC0, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x28, 0x6C, 0xFE, 0x6C, 0x28, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x38, 0x7C, 0x7C, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x7C, 0x7C, 0x38, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x66, 0x66, 0x66, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x6C, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 
  0x18, 0x18, 0x7C, 0xC6, 0xC2, 0xC0, 0x7C, 0x06, 0x86, 0xC6, 0x7C, 0x18, 0x18, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0xC2, 0xC6, 0x0C, 0x18, 0x30, 0x60, 0xC6, 0x86, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x38, 0x6C, 0x6C, 0x38, 0x76, 0xDC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x30, 0x30, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x02, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xCE, 0xD6, 0xD6, 0xE6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x18, 0x38, 0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x7C, 0xC6, 0x06, 0x0C, 0x18, 0x30, 0x60, 0xC0, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x7C, 0xC6, 0x06, 0x06, 0x3C, 0x06, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0C, 0x1C, 0x3C, 0x6C, 0xCC, 0xFE, 0x0C, 0x0C, 0x0C, 0x1E, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xFC, 0x0E, 0x06, 0x06, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x38, 0x60, 0xC0, 0xC0, 0xFC, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xFE, 0xC6, 0x06, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x06, 0x06, 0x0C, 0x78, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x0C, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xDE, 0xDE, 0xDE, 0xDC, 0xC0, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x66, 0x66, 0xFC, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xF8, 0x6C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x6C, 0xF8, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xFE, 0x66, 0x62, 0x68, 0x78, 0x68, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xDE, 0xC6, 0xC6, 0x66, 0x3A, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xCC, 0xCC, 0xCC, 0x78, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xE6, 0x66, 0x6C, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xF0, 0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x62, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC6, 0xEE, 0xFE, 0xFE, 0xD6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xDE, 0x7C, 0x0C, 0x0E, 0x00, 0x00, 
  0x00, 0x00, 0xFC, 0x66, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x7C, 0xC6, 0xC6, 0x60, 0x38, 0x0C, 0x06, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x7E, 0x7E, 0x5A, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x10, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC6, 0xC6, 0x6C, 0x6C, 0x38, 0x38, 0x6C, 0x6C, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0xFE, 0xC6, 0x86, 0x0C, 0x18, 0x30, 0x60, 0xC2, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x70, 0x38, 0x1C, 0x0E, 0x06, 0x02, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00, 0x00, 0x00, 0x00, 
  0x10, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 
  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xE0, 0x60, 0x60, 0x78, 0x6C, 0x66, 0x66, 0x66, 0x66, 0xDC, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC0, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x1C, 0x0C, 0x0C, 0x3C, 0x6C, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0xCC, 0x78, 0x00,
  0x00, 0x00, 0xE0, 0x60, 0x60, 0x6C, 0x76, 0x66, 0x66, 0x66, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x18, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x06, 0x06, 0x00, 0x0E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x66, 0x66, 0x3C, 0x00, 
  0x00, 0x00, 0xE0, 0x60, 0x60, 0x66, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0xE6, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xEC, 0xFE, 0xD6, 0xD6, 0xD6, 0xD6, 0xD6, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xF0, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x7C, 0x0C, 0x0C, 0x1E, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xDC, 0x76, 0x62, 0x60, 0x60, 0x60, 0xF0, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0xC6, 0x60, 0x38, 0x0C, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x10, 0x30, 0x30, 0xFC, 0x30, 0x30, 0x30, 0x30, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xD6, 0xD6, 0xFE, 0x6C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0x6C, 0x38, 0x38, 0x38, 0x6C, 0xC6, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0xF8, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xCC, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x0E, 0x18, 0x18, 0x18, 0x70, 0x18, 0x18, 0x18, 0x18, 0x0E, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x70, 0x18, 0x18, 0x18, 0x0E, 0x18, 0x18, 0x18, 0x18, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x3C, 0x66, 0xC2, 0xC0, 0xC0, 0xC0, 0xC2, 0x66, 0x3C, 0x0C, 0x06, 0x7C, 0x00, 0x00, 
  0x00, 0x00, 0xCC, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x0C, 0x18, 0x30, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x10, 0x38, 0x6C, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xCC, 0xCC, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x60, 0x30, 0x18, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x38, 0x6C, 0x38, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x3C, 0x66, 0x60, 0x60, 0x66, 0x3C, 0x0C, 0x06, 0x3C, 0x00, 0x00, 0x00, 
  0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC6, 0xC6, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x60, 0x30, 0x18, 0x00, 0x7C, 0xC6, 0xFE, 0xC0, 0xC0, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x66, 0x66, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x18, 0x3C, 0x66, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x60, 0x30, 0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xC6, 0xC6, 0x10, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 
  0x38, 0x6C, 0x38, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
  0x18, 0x30, 0x60, 0x00, 0xFE, 0x66, 0x60, 0x7C, 0x60, 0x60, 0x66, 0xFE, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x76, 0x36, 0x7E, 0xD8, 0xD8, 0x6E, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x3E, 0x6C, 0xCC, 0xCC, 0xFE, 0xCC, 0xCC, 0xCC, 0xCC, 0xCE, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x10, 0x38, 0x6C, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC6, 0xC6, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x60, 0x30, 0x18, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x30, 0x78, 0xCC, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x60, 0x30, 0x18, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0xC6, 0xC6, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7E, 0x06, 0x0C, 0x78, 0x00, 
  0x00, 0xC6, 0xC6, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xC6, 0xC6, 0x00, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x18, 0x18, 0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x38, 0x6C, 0x64, 0x60, 0xF0, 0x60, 0x60, 0x60, 0x60, 0xE6, 0xFC, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xF8, 0xCC, 0xCC, 0xF8, 0xC4, 0xCC, 0xDE, 0xCC, 0xCC, 0xCC, 0xC6, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x0E, 0x1B, 0x18, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0x70, 0x00, 0x00, 
  0x00, 0x18, 0x30, 0x60, 0x00, 0x78, 0x0C, 0x7C, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x0C, 0x18, 0x30, 0x00, 0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x18, 0x30, 0x60, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x18, 0x30, 0x60, 0x00, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0xCC, 0x76, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x76, 0xDC, 0x00, 0xDC, 0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 
  0x76, 0xDC, 0x00, 0xC6, 0xE6, 0xF6, 0xFE, 0xDE, 0xCE, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x3C, 0x6C, 0x6C, 0x3E, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x30, 0x30, 0x00, 0x30, 0x30, 0x60, 0xC0, 0xC6, 0xC6, 0x7C, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0x06, 0x06, 0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0xC0, 0xC0, 0xC2, 0xC6, 0xCC, 0x18, 0x30, 0x60, 0xCE, 0x93, 0x06, 0x0C, 0x1F, 0x00, 0x00, 
  0x00, 0xC0, 0xC0, 0xC2, 0xC6, 0xCC, 0x18, 0x30, 0x66, 0xCE, 0x9A, 0x3F, 0x06, 0x0F, 0x00, 0x00,
  0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 0x11, 0x44, 
  0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 
  0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77, 0xDD, 0x77,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
  0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x06, 0xF6, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
  0x36, 0x36, 0x36, 0x36, 0x36, 0xF6, 0x06, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
  0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
  0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
  0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
  0x36, 0x36, 0x36, 0x36, 0x36, 0x37, 0x30, 0x37, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x36, 0x36, 0x36, 0x36, 0x36, 0xF7, 0x00, 0xF7, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
  0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x3F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x18, 0x18, 0x18, 0x18, 0x18, 0x1F, 0x18, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
  0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0xFF, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 
  0x18, 0x18, 0x18, 0x18, 0x18, 0xFF, 0x18, 0xFF, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
  0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
  0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 
  0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0xD8, 0xD8, 0xD8, 0xDC, 0x76, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0xC6, 0xFC, 0xC6, 0xC6, 0xFC, 0xC0, 0xC0, 0xC0, 0x00, 0x00,
  0x00, 0x00, 0xFE, 0xC6, 0xC6, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x80, 0xFE, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0xFE, 0xC6, 0x60, 0x30, 0x18, 0x30, 0x60, 0xC6, 0xFE, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x66, 0x7C, 0x60, 0x60, 0xC0, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x7E, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x7E, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xFE, 0xC6, 0xC6, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x38, 0x6C, 0xC6, 0xC6, 0xC6, 0x6C, 0x6C, 0x6C, 0x6C, 0xEE, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x1E, 0x30, 0x18, 0x0C, 0x3E, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0xDB, 0xDB, 0xDB, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x03, 0x06, 0x7E, 0xCF, 0xDB, 0xF3, 0x7E, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x1C, 0x30, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x30, 0x1C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x7C, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0xC6, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x0E, 0x1B, 0x1B, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18,
  0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0xD8, 0xD8, 0xD8, 0x70, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x76, 0xDC, 0x00, 0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x38, 0x6C, 0x6C, 0x38, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x0F, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0xEC, 0x6C, 0x6C, 0x3C, 0x1C, 0x00, 0x00, 0x00, 0x00,
  0x00, 0xD8, 0x6C, 0x6C, 0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x70, 0x98, 0x30, 0x60, 0xC8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x7C, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static void write_font(unsigned char *buf, unsigned font_height)
{
  unsigned char seq2, seq4, gc4, gc5, gc6;
  unsigned i;

/* save registers
   set_plane() modifies GC 4 and SEQ 2, so save them as well */
  outb(VGA_SEQ_INDEX, 2);
  seq2 = inb(VGA_SEQ_DATA);

  outb(VGA_SEQ_INDEX, 4);
  seq4 = inb(VGA_SEQ_DATA);
/* turn off even-odd addressing (set flat addressing)
   assume: chain-4 addressing already off */
  outb(VGA_SEQ_DATA, seq4 | 0x04);

  outb(VGA_GC_INDEX, 4);
  gc4 = inb(VGA_GC_DATA);

  outb(VGA_GC_INDEX, 5);
  gc5 = inb(VGA_GC_DATA);
/* turn off even-odd addressing */
  outb(VGA_GC_DATA, gc5 & ~0x10);

  outb(VGA_GC_INDEX, 6);
  gc6 = inb(VGA_GC_DATA);
/* turn off even-odd addressing */
  outb(VGA_GC_DATA, gc6 & ~0x02);
/* write font to plane P4 */
  set_plane(2);
/* write font 0 */
  for(i = 0; i < 256; i++)
  {
    vmemwr(16384u * 0 + i * 32, buf, font_height);
    buf += font_height;
  }
#if 0
/* write font 1 */
  for(i = 0; i < 256; i++)
  {
    vmemwr(16384u * 1 + i * 32, buf, font_height);
    buf += font_height;
  }
#endif
/* restore registers */
  outb(VGA_SEQ_INDEX, 2);
  outb(VGA_SEQ_DATA, seq2);
  outb(VGA_SEQ_INDEX, 4);
  outb(VGA_SEQ_DATA, seq4);
  outb(VGA_GC_INDEX, 4);
  outb(VGA_GC_DATA, gc4);
  outb(VGA_GC_INDEX, 5);
  outb(VGA_GC_DATA, gc5);
  outb(VGA_GC_INDEX, 6);
  outb(VGA_GC_DATA, gc6);
}

/*****************************************************************************
SET TEXT MODES
*****************************************************************************/
void set_text_mode(int hi_res)
{
  u32int rows, cols, ht, i;

  if(hi_res)
  {
    //~ write_regs(g_90x60_text);
    cols = 90;
    rows = 60;
    ht = 8;
  }else{
    write_registers(g_80x25_text);
    cols = 80;
    rows = 25;
    ht = 16;
  }
  
  /* set font */
  write_font(g_8x16_font, 16);

  /* tell the BIOS what we've done, so BIOS text output works OK */
  pokew(0x40, 0x4A, cols);              /* columns on screen */
  pokew(0x40, 0x4C, cols * rows * 2);   /* framebuffer size */
  pokew(0x40, 0x50, 0);                 /* cursor pos'n */
  pokeb(0x40, 0x60, ht - 1);            /* cursor shape */
  pokeb(0x40, 0x61, ht - 2);
  pokeb(0x40, 0x84, rows - 1);          /* rows on screen - 1 */
  pokeb(0x40, 0x85, ht);                /* char height */

  /* set white-on-black attributes for all text */
  //~ for(i = 0; i < cols * rows; i++)
    //~ pokeb((u32int)video_memory, i * 2 + 1, 7);

  //restore the contents as they were before
  k_restore();

}
